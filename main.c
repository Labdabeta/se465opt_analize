#include <stdio.h>
#include <stdlib.h> //for atoi
/// Some buffer sizes
#define LINE_LENGTH_BUFFER_SIZE 256
#define FUNCTION_NAME_BUFFER_SIZE 100
#define NUM_USES_BUFFER_SIZE 10

typedef struct BugTypeTAG {
    char *fun1,*fun2,*scope,*bug;

    float confidence;
}BugType,*BugTypeHANDLE;

typedef struct CalleeListTAG {
    char *name;

    struct CalleeListTAG *next;
}CalleeList,*CalleeListHANDLE;

/** @brief A structure to hold a parsed file.
  * 
  * This structure holds a parsed bitcode file generated by the LLVM opt tool.
  * Internally it uses a linked list structure with each node representing a
  * single scope in the file.
  */
typedef struct ParsedFileTAG {
    char *fname;
    int num_uses;
    CalleeListHANDLE callees;

    struct ParsedFileTAG *next;
}ParsedFile,*ParsedFileHANDLE;

//returns NULL when out of input or invalid input is received
CalleeListHANDLE parse_callees(FILE *f)
{
    char *line;///<-- Represents a line read from f
    char fname[FUNCTION_NAME_BUFFER_SIZE];///<-- Represents a function name
    CalleeListHANDLE ret;///<-- The returned callee list structure
    int i;///<-- an iterator

    line = malloc(sizeof(char)*LINE_LENGTH_BUFFER_SIZE);
    fgets(line, LINE_LENGTH_BUFFER_SIZE, f);

    //Base case: newline returns NULL
    if (line[0]=='\n')
    {
        free(line);
        return NULL;
    }

    ret = malloc(sizeof(CalleeList));

    while (*(line++) != '\''); //scan to first '
    i=0;
    fname[i++] = *line;
    while (*(line++) != '\'')fname[i++] = *line;

    ret->name = fname;

    ret->next = parse_callees(f);
    return ret;
}

//returns NULL when out of input or invalid input is received
ParsedFileHANDLE parse_opt_file(FILE *f)
{
    //Variables
    char *line;///<-- Represents a line read from f
    char *save;///<-- Saved base of line for freeability
    char *fname;///<-- Represents a function name
    char *num;///<-- Represents a use number
    ParsedFileHANDLE ret;///<-- The returned parsed file structure
    int i;///<-- an iterator

    //Base case: empty file returns NULL
    if (feof(f)) return NULL;

    line = malloc(sizeof(char)*LINE_LENGTH_BUFFER_SIZE);
    save = line;
    fname = malloc(sizeof(char)*FUNCTION_NAME_BUFFER_SIZE);
    num = malloc(sizeof(char)*NUM_USES_BUFFER_SIZE);
    ret = malloc(sizeof(ParsedFile));

    fgets(line, LINE_LENGTH_BUFFER_SIZE, f);

    while (*(line++) != '\''); //scan to first '

    i=0;
    while (*line != '\'')
        fname[i++] = *(line++);
    fname[i] = 0;

    ret->fname = fname;

    while (*(line++) != '='); //scan to first =

    i=0;
    while (*line)
        num[i++] = *line++;

    ret->num_uses = atoi(num);
    free(num);
    free(line);

    ret->callees = parse_callees(f);
    
    ret->next = parse_opt_file(f);
    return ret;
}
typedef struct FunctionDataTAG {
    int id;
    int refCount;
    int numCallees;
    int *callees;
}FunctionData,*FunctionDataHANDLE;

typedef struct CallingMapTAG {
    int numFunctions;
    FunctionData *functions;
} CallingMap,*CallingMapHANDLE;

int main(int argc, char *argv[])
{
    char *input_file_name = argv[1];
    
    FILE *input_file = fopen(input_file_name,"r");
    
    char buf[LINE_LENGTH_BUFFER_SIZE];
    fgets(buf,LINE_LENGTH_BUFFER_SIZE,input_file);//get rid of the entry point line

    while (buf[0]!='\n')
        fgets(buf,LINE_LENGTH_BUFFER_SIZE,input_file);//get rid of <null function>

    ParsedFileHANDLE pf = parse_opt_file(input_file);

    while (pf)
    {
        printf("Scope: %s\n",pf->fname);
        while (pf->callees)
        {
            printf("    %s\n",pf->callees->name);
            pf->callees = pf->callees->next;
        }
        pf = pf->next;
    }
    return 0;
}
     
