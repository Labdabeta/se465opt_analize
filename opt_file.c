#include "opt_file.h"
#include <stdlib.h>

/// Some buffer sizes
#define LINE_LENGTH_BUFFER_SIZE 256
#define FUNCTION_NAME_BUFFER_SIZE 100

/** @brief A structure to hold a list of callees.
  * 
  * This structure holds a list of all callees in a scope.
  * Internally it uses a linked list structure with each node representing a
  * single scope in the file.
  */
typedef struct CalleeListTAG {
    char *name;

    struct CalleeListTAG *next;
}CalleeList;

/** @brief A structure to hold a parsed file.
  * 
  * This structure holds a parsed bitcode file generated by the LLVM opt tool.
  * Internally it uses a linked list structure with each node representing a
  * single scope in the file.
  */
typedef struct ParsedFileTAG {
    char *fname;
    CalleeList *callees;

    struct ParsedFileTAG *next;
}ParsedFile;

/** @brief A function to fill a CalleeList with appropriate data from a file.
  *
  * This function parses a scope from the file in opt format. It should be 
  * called with the file seeked to the start of a scope block, with the initial
  * line already parsed.
  *
  * Internally it parses a single line, then recurses to parse the rest. The
  * base case of the recursion is when an empty line is encountered.
  *
  * @return The list of callees, or NULL if the file format is inaccurate.
  */
static CalleeList *parse_callees(FILE *f)
{
    char *line;         ///<-- Represents a line read from f
    char *save;         ///<-- Saved base of line for freeability
    CalleeList *ret;    ///<-- The returned callee list structure
    int i;              ///<-- An iterator

    if (feof(f)) return NULL;

    line = malloc(sizeof(char)*LINE_LENGTH_BUFFER_SIZE);
    save = line;
    fgets(line, LINE_LENGTH_BUFFER_SIZE, f);

    //Base case: an empty line indicates an empty list
    if (*line != ' ')
    {
        free(line);
        return NULL;
    }

    ret = malloc(sizeof(CalleeList));

    while (*(line++) != '\''); //scan to first '
    i=0;

    ret->name = malloc(sizeof(char)*FUNCTION_NAME_BUFFER_SIZE);
    ret->name[i++] = *line;
    while (*(line++) != '\'') ret->name[i++] = *line;
    ret->name[i-1] = '\0';

    ret->next = parse_callees(f);
    free(save);
    return ret;
}

/** @brief A function to fill a ParsedFile with appropriate data from a file.
  *
  * This function parses a file in opt format. It should be called with the file
  * seeked to the start of a scope block, with the initial line ready to be 
  * read.
  *
  * Internally it parses a single scope, then recurses to parse the rest. The 
  * base case of the recursion is when an empty line is encountered.
  *
  * @return The list of scopes, or NULL if the file format is inaccurate.
  */
ParsedFileHANDLE parse_opt_file(FILE *f)
{
    char *line;         ///<-- Represents a line read from f
    char *save;         ///<-- Saved base of the line for freeability
    char *fname;        ///<-- Represents a function name
    ParsedFile *ret;    ///<-- The returned parsed file structure
    int i;              ///<-- An iterator

    //Base case: empty file returns NULL
    if (feof(f)) return NULL;

    line = malloc(sizeof(char)*LINE_LENGTH_BUFFER_SIZE);
    save = line;
    fname = malloc(sizeof(char)*FUNCTION_NAME_BUFFER_SIZE);
    ret = malloc(sizeof(ParsedFile));

    fgets(line, LINE_LENGTH_BUFFER_SIZE, f);

    while (*(line++) != '\''); //scan to first '

    i=0;
    while (*line != '\'')
        fname[i++] = *(line++);
    fname[i] = 0;

    ret->fname = fname;

    free(save);

    ret->callees = parse_callees(f);

    ret->next = parse_opt_file(f);
    return ret;
}
